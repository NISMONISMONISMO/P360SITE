<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>–¢–µ—Å—Ç –ü–∞–Ω–æ—Ä–∞–º—ã</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #000;
            font-family: Arial, sans-serif;
        }
        .info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            background: rgba(0,0,0,0.7);
            padding: 10px;
            border-radius: 5px;
            z-index: 100;
        }
        #container {
            width: 100vw;
            height: 100vh;
            cursor: grab;
        }
        #container.dragging {
            cursor: grabbing;
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>
    <div class="info">
        <h3>–¢–µ—Å—Ç –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–∏–π –ø–∞–Ω–æ—Ä–∞–º—ã:</h3>
        <ul>
            <li>‚úÖ –¶–∏–∫–ª–∏—á–µ—Å–∫–æ–µ –≤—Ä–∞—â–µ–Ω–∏–µ (–±–µ–∑ "–æ—Ç–∫–∏–¥—ã–≤–∞–Ω–∏—è")</li>
            <li>‚úÖ –ü—Ä–∞–≤–∏–ª—å–Ω–∞—è —Ä–µ–≤–µ—Ä—Å–∏—è (–≤–Ω–∏–∑ = —Å–º–æ—Ç—Ä–µ—Ç—å –≤–≤–µ—Ä—Ö)</li>
            <li>‚úÖ –û–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ —Å–∫–æ—Ä–æ—Å—Ç–∏ (–ø—Ä–æ—Ç–∏–≤ –±–µ—Å–∫–æ–Ω–µ—á–Ω–æ–≥–æ –≤—Ä–∞—â–µ–Ω–∏—è)</li>
            <li>üéÆ –ü–µ—Ä–µ—Ç–∞—â–∏—Ç–µ –º—ã—à—å—é –¥–ª—è –ø–æ–≤–æ—Ä–æ—Ç–∞</li>
            <li>üîç –ö–æ–ª–µ—Å–æ –º—ã—à–∏ –¥–ª—è –∑—É–º–∞</li>
        </ul>
    </div>
    
    <div id="container"></div>

    <script>
        // –°–æ—Å—Ç–æ—è–Ω–∏–µ –∫–∞–º–µ—Ä—ã
        const cameraState = {
            phi: 0,
            theta: Math.PI / 2,
            targetPhi: 0,
            targetTheta: Math.PI / 2,
            fov: 75,
            targetFov: 75
        };

        // –°–æ—Å—Ç–æ—è–Ω–∏–µ –º—ã—à–∏
        const mouseState = {
            isDown: false,
            startX: 0,
            startY: 0,
            previousX: 0,
            previousY: 0,
            velocityX: 0,
            velocityY: 0
        };

        // –ü–∞—Ä–∞–º–µ—Ç—Ä—ã
        const dampingFactor = 0.08; // –£–º–µ–Ω—å—à–µ–Ω–Ω–æ–µ –∑–∞—Ç—É—Ö–∞–Ω–∏–µ –¥–ª—è –±–æ–ª–µ–µ –ø–ª–∞–≤–Ω–æ–≥–æ –¥–≤–∏–∂–µ–Ω–∏—è
        const mouseSensitivity = 0.003;
        const minTheta = 0.1;
        const maxTheta = Math.PI - 0.1;

        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è Three.js
        const container = document.getElementById('container');
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        container.appendChild(renderer.domElement);

        // –°–æ–∑–¥–∞–Ω–∏–µ —Å—Ñ–µ—Ä—ã —Å —Ç–µ—Å—Ç–æ–≤–æ–π —Ç–µ–∫—Å—Ç—É—Ä–æ–π
        const geometry = new THREE.SphereGeometry(500, 64, 32);
        geometry.scale(-1, 1, 1);
        
        // –°–æ–∑–¥–∞–Ω–∏–µ –ø—Ä–æ—Å—Ç–æ–π –≥—Ä–∞–¥–∏–µ–Ω—Ç–Ω–æ–π —Ç–µ–∫—Å—Ç—É—Ä—ã –¥–ª—è —Ç–µ—Å—Ç–∞
        const canvas = document.createElement('canvas');
        canvas.width = 512;
        canvas.height = 256;
        const ctx = canvas.getContext('2d');
        
        // –ì—Ä–∞–¥–∏–µ–Ω—Ç —Å —Ä–∞–∑–º–µ—Ç–∫–æ–π
        const gradient = ctx.createLinearGradient(0, 0, 512, 256);
        gradient.addColorStop(0, '#ff6b1a');
        gradient.addColorStop(0.5, '#663399');
        gradient.addColorStop(1, '#2b1d52');
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, 512, 256);
        
        // –î–æ–±–∞–≤–ª—è–µ–º —Å–µ—Ç–∫—É –¥–ª—è –æ—Ä–∏–µ–Ω—Ç–∞—Ü–∏–∏
        ctx.strokeStyle = 'rgba(255,255,255,0.3)';
        ctx.lineWidth = 2;
        for (let i = 0; i <= 512; i += 64) {
            ctx.beginPath();
            ctx.moveTo(i, 0);
            ctx.lineTo(i, 256);
            ctx.stroke();
        }
        for (let i = 0; i <= 256; i += 32) {
            ctx.beginPath();
            ctx.moveTo(0, i);
            ctx.lineTo(512, i);
            ctx.stroke();
        }
        
        // –î–æ–±–∞–≤–ª—è–µ–º —Ç–µ–∫—Å—Ç –¥–ª—è –æ—Ä–∏–µ–Ω—Ç–∞—Ü–∏–∏
        ctx.fillStyle = 'white';
        ctx.font = '20px Arial';
        ctx.fillText('–°–ï–í–ï–†', 256, 30);
        ctx.fillText('–Æ–ì', 256, 240);
        ctx.fillText('–ó–ê–ü–ê–î', 50, 130);
        ctx.fillText('–í–û–°–¢–û–ö', 400, 130);
        
        const texture = new THREE.CanvasTexture(canvas);
        const material = new THREE.MeshBasicMaterial({ map: texture });
        const sphere = new THREE.Mesh(geometry, material);
        scene.add(sphere);

        // –§—É–Ω–∫—Ü–∏—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –∫–∞–º–µ—Ä—ã (—É–ª—É—á—à–µ–Ω–Ω–∞—è –≤–µ—Ä—Å–∏—è)
        function updateCamera() {
            // –ü—Ä–∏–º–µ–Ω—è–µ–º –∏–Ω–µ—Ä—Ü–∏—é, –µ—Å–ª–∏ –º—ã—à—å/—Ç–∞—á –Ω–µ –∞–∫—Ç–∏–≤–Ω—ã
            if (!mouseState.isDown) {
                // –ü—Ä–∏–º–µ–Ω—è–µ–º —Å–∫–æ—Ä–æ—Å—Ç—å —Å –∑–∞—Ç—É—Ö–∞–Ω–∏–µ–º –¥–ª—è –ø–ª–∞–≤–Ω–æ–≥–æ –∑–∞–º–µ–¥–ª–µ–Ω–∏—è
                cameraState.targetPhi -= mouseState.velocityX * mouseSensitivity;
                cameraState.targetTheta -= mouseState.velocityY * mouseSensitivity; // –ò–Ω–≤–µ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–Ω–æ–µ –≤–µ—Ä—Ç–∏–∫–∞–ª—å–Ω–æ–µ –¥–≤–∏–∂–µ–Ω–∏–µ

                // –ü—Ä–∏–º–µ–Ω—è–µ–º –∑–∞—Ç—É—Ö–∞–Ω–∏–µ —Å –±–æ–ª–µ–µ –µ—Å—Ç–µ—Å—Ç–≤–µ–Ω–Ω—ã–º –æ—â—É—â–µ–Ω–∏–µ–º
                mouseState.velocityX *= 0.85; // –£–º–µ–Ω—å—à–µ–Ω–Ω–æ–µ –∑–∞—Ç—É—Ö–∞–Ω–∏–µ –¥–ª—è –±–æ–ª–µ–µ –ø–ª–∞–≤–Ω–æ–≥–æ –æ—â—É—â–µ–Ω–∏—è
                mouseState.velocityY *= 0.85; // –£–º–µ–Ω—å—à–µ–Ω–Ω–æ–µ –∑–∞—Ç—É—Ö–∞–Ω–∏–µ –¥–ª—è –±–æ–ª–µ–µ –ø–ª–∞–≤–Ω–æ–≥–æ –æ—â—É—â–µ–Ω–∏—è

                // –û—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –∏–Ω–µ—Ä—Ü–∏—é, –µ—Å–ª–∏ —Å–∫–æ—Ä–æ—Å—Ç—å –æ—á–µ–Ω—å –º–∞–ª–∞
                if (Math.abs(mouseState.velocityX) < 0.1 && Math.abs(mouseState.velocityY) < 0.1) {
                    mouseState.velocityX = 0;
                    mouseState.velocityY = 0;
                }
            }

            // –û–±—Ä–∞–±–æ—Ç–∫–∞ —Ü–∏–∫–ª–∏—á–µ—Å–∫–æ–≥–æ –≤—Ä–∞—â–µ–Ω–∏—è –ø–æ –≥–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª–∏
            let deltaPhi = cameraState.targetPhi - cameraState.phi;
            
            // –ù–æ—Ä–º–∞–ª–∏–∑—É–µ–º –¥–µ–ª—å—Ç—É –¥–ª—è –∫—Ä–∞—Ç—á–∞–π—à–µ–≥–æ –ø—É—Ç–∏ –≤—Ä–∞—â–µ–Ω–∏—è
            if (deltaPhi > Math.PI) {
                deltaPhi -= 2 * Math.PI;
            } else if (deltaPhi < -Math.PI) {
                deltaPhi += 2 * Math.PI;
            }
            
            // –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º –º–∞–∫—Å–∏–º–∞–ª—å–Ω—É—é —Å–∫–æ—Ä–æ—Å—Ç—å –∏–∑–º–µ–Ω–µ–Ω–∏—è —É–≥–ª–∞ –¥–ª—è –ø—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–µ–Ω–∏—è –±–µ—Å–∫–æ–Ω–µ—á–Ω–æ–≥–æ –≤—Ä–∞—â–µ–Ω–∏—è
            const maxDeltaPhi = 0.3; // –£–º–µ–Ω—å—à–µ–Ω–Ω–∞—è –º–∞–∫—Å–∏–º–∞–ª—å–Ω–∞—è —Å–∫–æ—Ä–æ—Å—Ç—å –¥–ª—è –±–æ–ª–µ–µ –ø–ª–∞–≤–Ω–æ–≥–æ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è
            deltaPhi = Math.max(-maxDeltaPhi, Math.min(maxDeltaPhi, deltaPhi));
            
            cameraState.phi += deltaPhi * dampingFactor;
            cameraState.theta += (cameraState.targetTheta - cameraState.theta) * dampingFactor;
            cameraState.fov += (cameraState.targetFov - cameraState.fov) * dampingFactor;

            // –ù–æ—Ä–º–∞–ª–∏–∑—É–µ–º phi –≤ –¥–∏–∞–ø–∞–∑–æ–Ω–µ [-PI, PI] –¥–ª—è –Ω–µ–ø—Ä–µ—Ä—ã–≤–Ω–æ–≥–æ –≤—Ä–∞—â–µ–Ω–∏—è
            if (cameraState.phi > Math.PI) {
                cameraState.phi -= 2 * Math.PI;
            } else if (cameraState.phi < -Math.PI) {
                cameraState.phi += 2 * Math.PI;
            }
            
            // –¢–∞–∫–∂–µ –Ω–æ—Ä–º–∞–ª–∏–∑—É–µ–º targetPhi
            if (cameraState.targetPhi > Math.PI) {
                cameraState.targetPhi -= 2 * Math.PI;
            } else if (cameraState.targetPhi < -Math.PI) {
                cameraState.targetPhi += 2 * Math.PI;
            }

            // –ü—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ —Å—Ñ–µ—Ä–∏—á–µ—Å–∫–∏—Ö –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç –≤ –¥–µ–∫–∞—Ä—Ç–æ–≤—ã –¥–ª—è –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏—è –∫–∞–º–µ—Ä—ã
            const x = Math.sin(cameraState.theta) * Math.cos(cameraState.phi);
            const y = Math.cos(cameraState.theta);
            const z = Math.sin(cameraState.theta) * Math.sin(cameraState.phi);

            camera.lookAt(x, y, z);
            camera.fov = cameraState.fov;
            camera.updateProjectionMatrix();
        }

        // –û–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ –º—ã—à–∏ (—É–ª—É—á—à–µ–Ω–Ω—ã–µ)
        function handleMouseDown(event) {
            event.preventDefault();
            mouseState.isDown = true;
            mouseState.startX = event.clientX;
            mouseState.startY = event.clientY;
            mouseState.previousX = event.clientX;
            mouseState.previousY = event.clientY;
            // –°–±—Ä–∞—Å—ã–≤–∞–µ–º —Å–∫–æ—Ä–æ—Å—Ç—å –ø—Ä–∏ –Ω–∞–∂–∞—Ç–∏–∏ –¥–ª—è –Ω–µ–º–µ–¥–ª–µ–Ω–Ω–æ–≥–æ –æ—Ç–∫–ª–∏–∫–∞
            mouseState.velocityX = 0;
            mouseState.velocityY = 0;
            container.classList.add('dragging');
        }

        function handleMouseMove(event) {
            if (!mouseState.isDown) return;
            event.preventDefault();
            
            const deltaX = event.clientX - mouseState.previousX;
            const deltaY = event.clientY - mouseState.previousY;
            
            // –ì–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω–æ–µ –¥–≤–∏–∂–µ–Ω–∏–µ (–≤–ª–µ–≤–æ-–≤–ø—Ä–∞–≤–æ) —Å –ø–æ–≤—ã—à–µ–Ω–Ω–æ–π —á—É–≤—Å—Ç–≤–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å—é
            cameraState.targetPhi -= deltaX * mouseSensitivity;
            
            // –í–µ—Ä—Ç–∏–∫–∞–ª—å–Ω–æ–µ –¥–≤–∏–∂–µ–Ω–∏–µ (–≤–≤–µ—Ä—Ö-–≤–Ω–∏–∑) - –∏–Ω–≤–µ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–Ω–æ–µ –¥–≤–∏–∂–µ–Ω–∏–µ (–∫–∞–∫ –≤ Google Street View)
            // –ö–æ–≥–¥–∞ —Ç—è–Ω–µ–º –º—ã—à—å –≤–Ω–∏–∑ (deltaY > 0), –∫–∞–º–µ—Ä–∞ —Å–º–æ—Ç—Ä–∏—Ç –≤–≤–µ—Ä—Ö (theta —É–º–µ–Ω—å—à–∞–µ—Ç—Å—è)
            // –ö–æ–≥–¥–∞ —Ç—è–Ω–µ–º –º—ã—à—å –≤–≤–µ—Ä—Ö (deltaY < 0), –∫–∞–º–µ—Ä–∞ —Å–º–æ—Ç—Ä–∏—Ç –≤–Ω–∏–∑ (theta —É–≤–µ–ª–∏—á–∏–≤–∞–µ—Ç—Å—è)
            cameraState.targetTheta -= deltaY * mouseSensitivity;
            
            // –í—ã—á–∏—Å–ª—è–µ–º —Å–∫–æ—Ä–æ—Å—Ç—å –¥–ª—è –∏–Ω–µ—Ä—Ü–∏–∏
            mouseState.velocityX = deltaX;
            mouseState.velocityY = deltaY;
            
            // –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º –≤–µ—Ä—Ç–∏–∫–∞–ª—å–Ω—ã–π —É–≥–æ–ª
            cameraState.targetTheta = Math.max(minTheta, Math.min(maxTheta, cameraState.targetTheta));
            
            mouseState.previousX = event.clientX;
            mouseState.previousY = event.clientY;
        }

        function handleMouseUp() {
            mouseState.isDown = false;
            container.classList.remove('dragging');
            // –ò–Ω–µ—Ä—Ü–∏—è –±—É–¥–µ—Ç –ø—Ä–∏–º–µ–Ω—è—Ç—å—Å—è –≤ —Ü–∏–∫–ª–µ –∞–Ω–∏–º–∞—Ü–∏–∏
        }

        function handleWheel(event) {
            event.preventDefault();
            const delta = event.deltaY > 0 ? 5 : -5;
            cameraState.targetFov = Math.max(20, Math.min(120, cameraState.targetFov + delta));
        }

        // –î–æ–±–∞–≤–ª—è–µ–º –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ —Å–æ–±—ã—Ç–∏–π
        container.addEventListener('mousedown', handleMouseDown);
        container.addEventListener('mousemove', handleMouseMove);
        container.addEventListener('mouseup', handleMouseUp);
        container.addEventListener('mouseleave', handleMouseUp);
        container.addEventListener('wheel', handleWheel, { passive: false });

        // –û–±—Ä–∞–±–æ—Ç–∫–∞ –∏–∑–º–µ–Ω–µ–Ω–∏—è —Ä–∞–∑–º–µ—Ä–∞ –æ–∫–Ω–∞
        function handleResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        window.addEventListener('resize', handleResize);

        // –ê–Ω–∏–º–∞—Ü–∏–æ–Ω–Ω—ã–π —Ü–∏–∫–ª
        function animate() {
            updateCamera();
            renderer.render(scene, camera);
            requestAnimationFrame(animate);
        }

        animate();
    </script>
</body>
</html>